\chapter{Introduction}
\label{chap:intro}

Today's general purpose file systems fail to utilize the full bandwidth of the
underlying hardware.
Widely used inode-based file systems, such as ext4, XFS, and Btrfs, can write
large files at near disk bandwidth,
but typically create small files at less than 3\% of the disk bandwidth.
Similarly, these file systems can read large files at near disk bandwidth,
but scanning directories with many small files is slow, and the performance
degrades when the file system ages~\citep{betrfs3}.

At the heart of this issue is how data is organized on disk.
The most common design pattern for modern file systems is to use multiple layers
of indirection.
The inode number of a file or directory connects the name of an entry in a
directory to its metadata location on disk.
The metadata of an inode contains extents that describes the physical location
and length of data at different offsets.
Indirection simplifies implementation of the file system, and makes some
operations, such creating files and appending files, easy to implement.
In particular, namespace operations are simple and flexible.
For example, a rename is just a pointer swing, moving an entry from one
directory to another directory.
However, indirection doesn't impose any constraint on how metadata and data
are placed on the disk.
In the worst case, the metadata of entries under a directory and the content of
a file can end up scattered over the disk.
Heuristics, such as cylinder groups~\citep{ffs1}, are designed to mitigate this
problem.
However, on modern inode-based file systems, unless the metadata or data are
modified, their location doesn't change.
Therefore, after disk space is allocated and freed over file system aging,
the free space on disk becomes scattered,
leading to bad performance for both reads and writes.

One attempt to solve the problem of random writes is the log-structured file
system~\citep{lfs}.
The log-structure file system treats the disk as a log, so small random writes
becomes log appends, which are significantly faster.
However, the log cleaner in a log-structured file system has severe impact on
performance~\citep{lfsbsd}, especially when the log is full.
And the log-structured file system still uses multiple levels of
indirection, resulting in slow directory traversals.

An alternative design is to use full-path indexing upon write-optimized
dictionaries (WODs) in a file system, known to have good performance on nearly
all operations.
On one hand, WODs have fast random write performance.
A WOD divides its data into multiple levels whose sizes grow exponentially.
Writes are put to the lowest level, and gradually merged to higher levels in
batches.
This merging process in a WOD keeps data sorted in a certain order at each level
and acts as a cleaner to garbage-collect lower levels.
On the other hand, full-path indexing ensures metadata and data in
depth-first-search order, that is, lexicographic order by the full-path names
of files and directories.
With full-path indexing, metadata and data under one directory are close to each
other in key space, which, combined with the sorted order maintained by
WODs, leads to good locality and fast directory traversals.
Prior work~\citep{betrfs1,betrfs1tos,betrfs2,betrfs2tos,betrfs3} of this design
realizes efficient implementation of many file-system operations, such as random
writes, file creates and directory traversals,
but a few operations still have prohibitively high overheads.

The Achilles' heel of such design is the performance of namespace operations,
in particular, renaming large files and directories.
For instance, renaming a large directory changes the full-paths of all files
and directories under it, which updates keys of the metadata and
data and moves them in the key space.
Competitive performance for namespace operations in full-path-indexed file
systems should complete in an I/O-efficient manner.

However, prior work mainly focuses on the schema level of the file system, i.e.,
how metadata and data are keyed and indexed in the WODs.
The full-path-indexed file system usually implements a rename by
fetching all key/value pairs of metadata and data,
inserting them back with updated keys, and deleting old key/value pairs.
Therefore, a rename needs to call several operations for each affected full-path
names, leading to bad performance.
Or, the file system partly backs away from full-path-indexing and adopts
relative-path-indexing, a hybrid of full-path-indexing and indirection.
This approach not only breaks the locality of full-path-indexing, but also
taxes other operations for efficient namespace operations.

This dissertation presents I/O-efficient ways to do namespace operations in a
full-path-indexed, write-optimized file system.
Specifically, though full-path indexing limits possible change on the schema
level, we observe that it can make all full-path names under a directory
contiguous in key space.
And the underlying WOD, \bets, has a tree structure, which makes it possible to
move or clone a contiguous key range efficiently.
Therefore, we dig into the underlying \bets, and implements two new operations,
range-rename and range-clone, that completes file system renames and clones with
bounded number of I/Os.

Chapter~\ref{chap:bg} talks about the necessary background of this dissertation.
We start with a presentation of the write-optimized \bets,
showing the idea of write-optimization.
Then, we describes full-path-indexed \betrfs and relative-path-indexed \betrfs.
The full-path-indexed \betrfs shows the benefit of full-path indexing combined
with write-optimization, but suffers from slow renames.
The relative-path-indexed \betrfs has good rename performance, but breaks the
full-path indexing and taxes other operations for efficient renames.

Chapter~\ref{chap:rename} presents the range-rename operation on \bets,
which full-path-indexed \betrfs can use to implement file system renames.
A range-rename updates all keys with one prefix to another prefix efficiently
through two techniques, \textbf{key lifting} and \textbf{tree surgery}.

Chapter~\ref{chap:clone} expands range-rename to range-clone,
which full-path-indexed \betrfs can use to implement both file or directory
renames and clones.
We first show how to implement range-clone with range-rename techniques by
transforming \bets into \bedags.
Then, we introduces a new type of messages, \goto messages, that works as other
messages in \bedags, fitting range-clone into write-optimization.

Chapter~\ref{chap:eval} evaluates the implementation.
We compare full-path-indexed \betrfs with range-rename or range-clone to
widely used file systems on micro and application benchmarks.
We also put a particular focus on benchmarking the range-rename and range-clone
operations.

Chapter~\ref{chap:related} summarize some previously published work related to
this work.
We organize related work by topic, and talk in detail about work that is closely
related to this work.

Chapter~\ref{chap:conclusion} summarizes and concludes the dissertation.

The primary contribution of this dissertation is to show that there is no
trade-off between efficient namespace operations and locality.
Efficient renames are possible in a full-path-indexed file system, which ensures
locality.
And full-path indexing creates more opportunities for namespace operations,
such as directory clones.

