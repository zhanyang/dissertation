\chapter{Range-Rename}
\label{chap:rename}

This chapter describes the \bet operation, range-rename, that makes efficient
renames possible on full-path-indexed \betrfs.
To perform a rename, \betrfs simply calls the range-rename function of \fti,
which updates all related key/value pairs in the underlying \bets efficiently.
This chapter starts by describing the range-rename interface,
followed by two key techniques that make efficient range-rename operation
possible on \bets, \textbf{tree surgery} and \textbf{key lifting}.
At last, this chapter discusses the changes that \betrfs makes to adopt
range-renames.

\section{The range-rename interface}

Range-rename is a new key/value store function defined as:
range-rename(\spre, \dpre).
Define a source key/value pair as a key/value pair whose key has prefix \spre
and a destination key/value pair as a key/value pair whose key has prefix \dpre.
Range-rename(\spre, \dpre) does three things:
\begin{itemize}
\item it deletes all destination key/value pairs from the key/value store;
\item then, for any source key/value pair $(k,v)$ in the key/value store,
it inserts a key/value pair $(k',v)$ to the key/value store,
where $k$ is the concatenation of \spre and some suffix $s$ and $k'$ is the
concatenation of \dpre and the same suffix $s$;
\item at last, it deletes all source key/value pairs from the key/value store.
\end{itemize}
In other words, a range-rename deletes all destination key/value pairs and
updates all source key/value pairs to have \dpre.

To see how range-rename accomplishes renames in full-path-indexed \betrfs,
consider renaming file ``/foo'' to ``/bar''.
In \mdb, \betrfs needs to insert the destination key ``/bar''
(this insert overwrites the old value of ``/bar'', if it exists)
and delete the source key ``/foo'', resulting in two function calls to \fti.
On the other hand, in \ddb, \betrfs needs to delete all data keys of ``/bar''
(POSIX allows file renames to overwrite the destination file) and update all
data keys of ``/foo'' to be data keys of ``/bar''.
The whole work in \ddb can be done by calling range-rename(``/foo'',``/bar'')
(data keys are the concatenation of the full-path and an 8-byte block number).

Similarly, consider renaming directory ``/baz'' to ``/qux''.
In \mdb, \betrfs also needs to insert the destination key ``/qux'' and deletes
the source key ``/baz'' with two functions calls to \fti.
Additionally, \betrfs needs to update all keys with prefix ``/baz/'' to have
prefix ``/qux/''
(POSIX only allows directory renames to overwrite an empty directory, which
means there cannot be any key with prefix ``/qux/''),
which is covered in range-rename(``/baz/'', ``/qux/'').
Likewise, in \ddb, \betrfs also needs to update all keys with prefix ``/baz/''
to have prefix ``/qux/'', which is done in range-rename(``/baz/'', ``/qux/'')
(directory doesn't have any data key).

In summary, full-path-indexed \betrfs can finish a file rename by calling three
functions of \fti: an insert, a delete and a range-rename.
And a directory rename can be done with an insert, a delete and two
range-renames.
Therefore, efficient renames are possible in full-path-index \betrfs if
\fti can perform range-renames efficiently on the underlying \bets.

\section{Range-rename on \bets}

This section describes the approach to do a range-renames on the \bet
with a bounded number of IOs.
The efficient range-rename requires lexicographic key order so that keys with
the same prefix are contiguous in the key space.
With contiguous keys, it is possible to have an isolated subtree that contains
and only contains all key/value pairs of a certain prefix.
The range-rename performs \textbf{tree surgery} to create such an isolated
subtree.
Then, the range-rename moves the subtree to another location on the \bet and
updates the prefixes of keys in the subtree through \textbf{key lifting}.

This section first describes tree surgery and key lifting, and then shows how
range-rename can be done with these two techniques.

\subsection{Tree surgery}

\begin{figure}
    \begin{subfigure}{\textwidth}
        \centering
        \includegraphics[width=.9\linewidth]{fig/slice-1}
        \caption{\label{subfig:slice-1} The \bet before tree surgery.}
    \end{subfigure}
    \begin{subfigure}{\textwidth}
        \centering
        \includegraphics[width=.9\linewidth]{fig/slice-2}
        \caption{\label{subfig:slice-2} Tree surgery splits leaf nodes.}
    \end{subfigure}
    \begin{subfigure}{\textwidth}
        \centering
        \includegraphics[width=.9\linewidth]{fig/slice-3}
        \caption{\label{subfig:slice-3} Tree surgery splits the LCA.}
    \end{subfigure}
    \caption[Tree surgery example]{\label{fig:slice}
        Tree surgery slices out an isolated subtree of prefix ``/R/''.}
\end{figure}

The goal of tree surgery is to create an isolated subtree of a certain
prefix $p$ on the \bet.
In the \bet, each node covers a certain key range, bounded by the key range and
pivots of its parent.
For a certain key range $(p_{min}, p_{max})$ ($p_{min}$ and $p_{max}$ are the
minimum and maximum keys with prefix $p$, respectively), there are three types
of nodes: nodes whose range are completely out of the key range, nodes whose
range are completely in the key range, and nodes whose range partly overlapped
with the key range (called \textbf{fringe nodes}).

Figure~\ref{subfig:slice-1} shows an example of a \bet.
Node A, B and C are non-leaf nodes with buffers and pivots.
Node D, E, F, G and H are leaf nodes that only store key/value pairs.
Parent-to-leaf pointers in the figure link all nodes into a tree.
Consider prefix ``/R/'',
Node B, D and E are completely out of the key range $(/R/_{min}, /R/_{max})$,
Node G is completely in the key range, and other nodes are fringe nodes.

\paragraph{Identifying fringe nodes.}
The first step of tree surgery is to identify all fringe nodes.
This is done by performing root-to-leaf traversals with two keys,
$p_{min}$ and $p_{max}$.
because a fringe node must have one of the two keys in its range.

An important fringe node for tree surgery is the \textbf{LCA}
(Lowest Common Ancestor) of two keys: the LCA is the \bet node lowest in the
tree on the search path for both keys (and hence including all keys in between).
In Figure~\ref{subfig:slice-1}, Node C is the LCA.
The subtree rooted at the LCA is the lowest subtree in the \bet that covers
the whole range $(p_{min}, p_{max})$.
And tree surgery uses this subtree to create its isolated subtree by splitting
nodes.
While traversing the \bet, tree also flushes messages in the fringe node from
parent to child to ensure that no message stays above the subtree.

\paragraph{Slicing.}
The second step is to slice out the isolated subtree by splitting fringe nodes
from bottom up.
The goal of slicing to separated unrelated key/value pairs in the fringe nodes
from key/values in the range.
Slicing uses the same code used for standard \bet node splits, but slicing
divides the node at the slicing key, which is $p_{min}$ or $p_{max}$ rather than
picking a key in the middle of the node.

In Figure~\ref{subfig:slice-2}, tree surgery splits Node F with key
$/R/_{min}$, generating new Node F that only contains keys with prefix
``/R/'' and another Node F$'$ that doesn't contain another key with prefix
``/R/''.
Likewise, tree surgery splits Node H into new Node H and Node H$'$ with key
$/R/_{max}$.
At last, in Figure~\ref{subfig:slice-3}, tree surgery splits the LCA, Node C,
into new Node C, Node C$'$ and Node C$''$ with both keys, $/R/_{min}$ and
$/R/_{max}$.
The subtree rooted at the new Node C is the isolated subtree that contains and
only contains all keys with prefix ``/R/''.

\subsection{Key lifting}

\begin{figure}
    \begin{subfigure}{\textwidth}
        \centering
        \includegraphics[width=.9\linewidth]{fig/lift-1}
        \caption{\label{subfig:lift-1} A subtree of ``/red/'' keys bounded by
            pivots $/red/_{min}$ and $/red/_{max}$ in the parent}
    \end{subfigure}
    \begin{subfigure}{\textwidth}
        \centering
        \includegraphics[width=.9\linewidth]{fig/lift-2}
        \caption{\label{subfig:lift-2} The same subtree bounded by pivots
            $/blue/_{min}$ and $/blue/_{max}$ in the parent}
    \end{subfigure}
    \caption[Key lifting example]{\label{fig:lift}
        Key lifting lifts prefixes from the subtree. Keys in the same subtree
        are viewed with different prefixes when the pivots in its parent
        changes.}
\end{figure}

Tree surgery slices out a subtree of a certain prefix, which can be moved to
another location in the \bet.
However, the keys in the subtree will not be coherent with the new location in
the tree.
As part of a range-rename, the prefixes of all keys in this subtree need to be
updated.
The particularly concerning case is when the subtree is a very large.
Updating the prefixes by traversing the subtree costs a lot of IOs, touching
nodes that would otherwise be untouched by the tree surgery.

Key lifting eliminates the need to update prefixes in the subtree by
transferring \bets to lifted \bets.
The idea of key lifting comes from the observation that with the lexicographic
order, all keys in the range of two pivots must have the same prefix that is
the \textbf{LCP} (Longest Common Prefix) of the pivots.
Therefore, this LCP is redundant information in the subtree of the two pivots
and can be removed from the subtree.

At a high level, each parent in a lifted \bet stores each child's common,
lifted key prefix alongside the pointer to the child.
Child nodes only store differing key suffixes.
This approach encodes the complete key in the path taken to reach a given node
and one can then modify the prefix for a lifted subtree by only modifying the
parent node, eliminating the need to change key and pivot prefixes in all nodes
of a subtree.

For example, in Figure~\ref{subfig:lift-1}, the subtree rooted at Node B is
bounded by ``/red/$_{min}$'' and ``/red/$_{max}$'' in Node A.
Therefore, all keys in the subtree must have prefix ``/red/'' and key lifting
removes this prefix from the subtree (marked as strike-through in keys).
Likewise, Node D is bounded by ``m/a'' and ``m/z'' in Node B
(note ``/red/'' is already lifted from the sutbree rooted at Node B),
so key lifting removes the prefix ``m/'' from Node D.
In Figure~\ref{subfig:lift-2}, the same subtree, which contains exactly the
same key/value pairs, is moved to a different location, bounded by
``/blue/$_{min}$'' and ``/blue/$_{max}$'' in Node A.
Because the prefix encoded in the parent-to-child pointer in Node A' becomes
``/blue/'', all keys in the subtree have ``/blue/'' prefixes instead.

Key lifting doesn't introduce additional IOs to reads and writes on lifted
\bets.
Queries need to reconstruct the full key by concatenating prefixes during a
root-to-leaf traversal.
When flushing, the lifted prefix must be removed from messages being flushed
to the child.
A node split adds a pivot to the parent, changing the lifted prefix in the
parent-to-child pointer, so it needs to update keys in the resulting children.
However, this doesn't incur additional IO.
Similarly, no additional IO is required in node merges.

Key lifting is completely transparent to the application using the key/value
store.
From the file system's perspective, it is still storing key/value pairs with
full-path keys.

\subsection{Put them together}

\begin{figure}
    \begin{subfigure}{\textwidth}
        \centering
        \includegraphics[width=.7\linewidth]{fig/rr-1}
        \caption{\label{subfig:rr-1} The \bet before the range-rename.}
    \end{subfigure}
    \begin{subfigure}{\textwidth}
        \centering
        \includegraphics[width=.7\linewidth]{fig/rr-2}
        \caption{\label{subfig:rr-2} The range-rename performs tree surgery
            to slices out two subtrees.}
    \end{subfigure}
    \begin{subfigure}{\textwidth}
        \centering
        \includegraphics[width=.7\linewidth]{fig/rr-3}
        \caption{\label{subfig:rr-3} The range-rename swaps the subtree and
            injects a range-delete.}
    \end{subfigure}
    \caption[A range-rename example]{\label{fig:rr}
        An example of range-rename(``/R/'', ``/B/'').}
\end{figure}

\paragraph{Tree Surgery.}
A range-rename first slices out two isolated subtrees on lifted \bets
simultaneously, one of \spre and the other of \dpre.
The range-rename requires the source and destination subtrees to be at the same
height.
Therefore, for a subtree with a lower LCA, the range-rename keeps slicing its
ancestors by adding nodes with only one child.

Then, the range-rename swaps these two subtrees and injects a range-delete
message for source keys, which leverages the builtin garbage collection
mechanism in \fti to reclaim the destination subtree.

\paragraph{Transplant.}
An example of range-rename(``/R/'', ``/B/'') is shown in Figure~\ref{fig:rr}.
Figure~\ref{subfig:rr-1} shows the lifted \bet before the range-rename.
In Figure~\ref{subfig:rr-2}, the source (rooted at Node B) and destination
subtrees (rooted at Node C) are sliced out by tree surgery.
Note ``/R/'' is lifted from the source subtree and ``/B/'' is lifted from the
destination subtree.
Figure~\ref{subfig:rr-3} shows the lifted \bet after swap the source and
destination subtree, with a range-delete message for keys with ``/R/'' prefix.

\paragraph{Healing.}
The \fti implementation maintains the invariant that all non-leaf nodes have
between 4 and 16 children, which bounds the height of the tree.
However, tree surgery splits nodes with its own keys, which might break the
constraint.

This situation is handled by triggering a rebalancing within the tree after
the range-rename.
Specifically, if a node has only one child, the slicing process will merge
it after completing the work of the rename.
After the transplant completes, there may be a number of \bet nodes in memory at
the fringe around the source and destination that have fewer children than
desired.
The healing process merges these smaller nodes back together,
using the same approach as a typical \bet merge.
At this point, it is also possible that this could trigger a rebalancing within
the tree.

\paragraph{Complexity.}
At most 4 root-to-leaf paths are traversed, dirtying all nodes along the paths.
These nodes will need to be read, if not in cache, and written back to disk as
part of the check-pointing process.
Therefore the number of I/Os is at most proportional to the height of the \bet,
which is logarithmic in the size of the tree.

During tree surgery, there is lifting work along all nodes that are sliced or
merged.
However, the number of such nodes is at most proportional to the height of the
tree.
Thus, the number of nodes that must be lifted during a range-rename is no more
than the nodes that must be sliced during tree surgery, and proportional to
the height of the tree.

In summary, the IO cost of a range-rename is $O(log_{B}{N}/\varepsilon)$.

\paragraph{Crash Consistency.}
In general, \fti ensures crash consistency by keeping a redo log of pending
messages and applying messages to nodes copy-on-write.
At periodic intervals, \fti ensures that there is a consistent checkpoint
of the tree on disk.
Crash recovery simply replays the redo log since the last checkpoint.
Range-rename works within this framework.

A range-rename is {\em logically applied} as soon as the
range-rename and its corresponding transaction commit entries are inserted into
the redo log.
The range rename is durable as soon as the redo log entry is written to disk.
If the system crashes after a range rename is logged, the recovery will see a
prefix of the message history that includes the range rename,
and performs the corresponding range-rename on the \bet.

\paragraph{Latency.}
A rename returns to the user once a log entry is in the journal and the root
node of the \bet is locked.
At this point, the rename has been applied in the VFS to in-memory metadata,
and as soon as the log is fsynced, the rename is durable.

We then hand off the rest of the rename work to two background threads
to do the cutting and healing.
The prototype in this paper only allows a backlog of one pending, large rename,
since we believe that concurrent renames are relatively infrequent.
The challenge in adding a rename work queue is ensuring consistency between the
work queue and the state of the tree.

\paragraph{Atomicity and Transactions.}
The \fti in \betrfs implements \bets multi-version concurrency control by
augmenting messages with a logical timestamp.
Messages updating a given key range are always applied in logical order.
Multiple messages can share a timestamp, giving them transactional semantics.

To ensure atomicity for a range rename, we create an MVCC ``hazard'':
read transactions ``before'' the rename must complete before the surgery
can proceed.
Tree nodes in the \bet are locked with reader-writer locks.
We write-lock tree nodes hand-over-hand, and left-to-right to identify
the LCAs.
Once the LCAs are locked, this serializes any new read or write
transactions until the rename completes.
The lock at the LCA creates a ``barrier''---operations can complete ``above'' or
``below'' this lock in the tree, although the slicing will wait for concurrent
transactions to complete before write-locking that node.
Once the transplant completes, the write-locks on the parents above LCAs are
released.

For simplicity, before the range rename is applied, we ensure that all messages
representing changes in the affected key range(s) that logically occurred before
the range rename are flushed below the LCA.
All messages that logically occur after the rename follow the new path through
the tree to the destination or source.
This strategy ensures that, when each message is flushed and applied, it sees a
point-in-time consistent view of the subtree.

\section{\betrfs key ordering}

Before range-rename, there is only one readdir constraint on \betrfs key
ordering.
In \betrfs, a readdir uses range-queries to fetch all child entries under the
directory.
Therefore, all files and directories immediately under one directory should be
contiguous in keyspace.
The \texttt{memcmp} key ordering fails this constraint.
Consider entries ``/bar/dir'', ``/bar/dir/file'' and ``/bar/file'' in the that
order, a readir for directory ``/bar'' needs to skip ``/bar/dir/file''.
In the worst case, a readdir might need to skip all keys in the key/value store.

The lifted \bet imposes the lexicographic constraints because key lifting only
works properly with lexicographic key ordering.
The old \betrfs key ordering, which sorts full-paths first by the number of
slashes and then by memcmp, doesn't satisfy this constraint.

In order to adopt range-rename, \betrfs tweaks its full-path keys by adding one
additional slash alongside the last slash.
Now, ``/foo'' and ``/foo/bar'' become ``//foo'' and ``/foo//bar'', respectively
(for correct ordering, `\textbackslash x01' is used as a slash).
With the new full-path keys, \betrfs can use \texttt{memcmp} as the key
comparison function while satisfying the readdir constraint.


\section{Summary}

This chapter presents a new key/value store operation, range-rename.
Renames on full-path-indexed \betrfs can be done with an insert, a delete and
one or two range-renames.
And on lifted \bets, a range-rename can be done efficiently with tree surgery.

\betrfs with range-rename demonstrates the possibility of consolidating
efficient renames into full-path-indexed file systems, showing the possibility
of building file systems that are good at locality and namespace operations.

