\chapter{Background}
\label{chap:bg}

This chapter gives the background of \betrfs.
\betrfs is a full-path-indexed file system based on write-optimized \bets.
The benefit of write-optimized \bets is random write performance,
while the benefit of full-path-indexing is spatial locality, even in an aged
file system.
This chapter introduces \bets and then the full-path-indexing schema of \betrfs.

\section{\bets}
\label{sec:bet}

\bets~\citep{bet,betlogin} are \btrees, augmented with buffers in non-leaf
nodes.
New writes are injected as messages into the buffer of the root node of a \bet.
When a node's buffer becomes full, messages are flushed from that node's buffer
to one of its children's buffers.
The leaves of the \bet store key/value pairs, as in a \btree.
Besides checking key/value pairs in the leaves, point and range queries in a
\bet must check related messages in the buffers on the root-to-leaf path.

\begin{table}[t]
    \centering
    \begin{tabular}{c | c c c}
        \hline
        Data Structure & Insert & Point Query & Range Query \\
        \hline
        \hline
        \btree & $O(log_{B}{N})$ & $O(log_{B}{N})$ & $O(log_{B}{N} + k/B)$\\
        \hline
        \bet & $O({log_{B}{N}}/{\varepsilon B^{1 - \varepsilon}})$ & $O({log_{B}{N}}/{\varepsilon})$ & $O({log_{B}{N}}/{\varepsilon} + k/B)$ \\
        \hline
        \bet ($\varepsilon=0.5$) & $O(log_{B}{N}/{\sqrt{B}})$ & $O(log_{B}{N})$ & $O(log_{B}{N} + k/B)$ \\
        \hline
    \end{tabular}
    \caption{\label{tab:betbtree} The asymptotic IO costs of \btrees and \bets.}
\end{table}

\bets are asymptotically faster than \btrees, as shown in
Table~\ref{tab:betbtree}.
Consider a \btree with $N$ key/value pairs and each node can hold $B$ keys.
The tree has fanout $B$, so its height is $O(log_{B}{N})$.
Inserts and point queries need to fetch all nodes along the root-to-leaf path,
resulting in $O(log_{B}{N})$ IOs.
A range query for $k$ key/value pairs requires $O(log_{B}{N} + k/B)$ IOs.

For comparison, a \bet with node size $B$ has fanout $B^{\varepsilon}$, where
$0 < \varepsilon \leq 1$.
Therefore, pivot keys in a non-leaf node consume $B^{\varepsilon}$ space and
the remaining $(B - B^{\varepsilon})$ space is used for buffers.
The \bet has height $O(log_{B}{N}/\varepsilon)$, because the fanout is
$B^{\varepsilon}$.
A point query fetches all nodes along the root-to-leaf path with
$O(log_{B}{N}/\varepsilon)$ IOs and a range query for $k$ key/value pairs
requires $O({log_{B}{N}}/{\varepsilon} + k/B)$ IOs.
However, the cost of an insert consists of injecting to the root node and
flushing down at each level.
When flushing, \bets has $O(B - B^{\varepsilon})$ messages and $B^{\varepsilon}$
children.
At leave one child can receive at least
$O((B - B^{\varepsilon})/B^{\varepsilon}) = O(B^{1 - \varepsilon})$ messages.
Therefore, the amortized cost of an insert in one flush is
$O(1/B^{1 - \varepsilon})$.
As an insert must be flushed $O(log_{B}{N}/\varepsilon)$ times, the amortized
cost of an insert is $O({log_{B}{N}}/{\varepsilon B^{1 - \varepsilon}})$.
A \bet with $\varepsilon = 1$ is equivalent to a \btree.
And if we pick $\varepsilon = 1/2$, the point and range query costs of the \bet
become $O(log_{B}{N})$ and $O(log_{B}{N} + k/B)$, which is the same as a \btree,
but the insert cost becomes $O(log_{B}{N}/{\sqrt{B}})$, which is faster by a
factor of $\sqrt{B}$.

One important change in \bets is that the IO costs for point queries and inserts
are asymmetric.
If an application want to update the old value associated with a key,
it must perform a point query to get the old value before inserting.
This read-before-write behavior degrades the updating performance to point query
performacne.

\bets support ``upserts'' to avoid read-before-write.
An upsert inject a message with the key and a delta.
When the upsert message is flushed to the leaf, it updates the value associated
with the key with a user-specified function and the delta in the message.
With upsert messages, queries need to compute value on the fly, however, this
doesn't change the IO costs of queries.
On the other hand, updating an old value becomes as fast as an insert.

\section{\betrfs}

\begin{figure}
    \centering
    \includegraphics{proposal/fig/betrfs}
    \caption{\label{fig:betrfs} The \betrfs architecture.}
\end{figure}

\betrfs~\citep{betrfs1,betrfs1tos} is a Linux in-kernel file
system built upon \fti~\citep{fti}, which implements \bets and exposes a
key/value interface similar to BerkelyDB.
The architecture of \betrfs is shown in Figure~\ref{fig:betrfs}.
\betrfs interacts with \fti through point operations, such as \texttt{put},
\texttt{get} and \texttt{del}, as well as range queries with cursors
(\texttt{c\_getf\_set\_range} and \texttt{c\_getf\_next}).
\betrfs also uses the transaction interface of \fti to execute multiple
operations atomically.
A redo log and periodic checkpoints (every 60 seconds) in \fti ensure that
changes can be made persistent on the underlying storage media.

\Fti cannot be integrated into a Linux kernel module easily because
it is a userspace library that assumes libc functions and system calls.
We built a shim layer called \texttt{klibc} which implements all functions \fti
requires.
By implementing those functions in \texttt{klibc} instead of directly modifying
\fti, we are able to migrate \fti into the kernel module intact.
